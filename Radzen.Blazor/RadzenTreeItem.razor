@using Radzen
@implements IDisposable
<li class="rz-treenode">
    <div class="@($"rz-treenode-content {(selected ? "rz-treenode-content-selected" : "")}")" @onclick="@Select">
        @if (ChildContent != null || HasChildren)
        {
            <span class="@($"rz-tree-toggler rzi {(expanded ? "rzi-caret-down" : "rzi-caret-right")}")" @onclick="@Toggle" @onclick:stopPropagation></span>
        }
        @if(Tree != null && Tree.AllowCheckBoxes)
        {
            <RadzenCheckBox TValue="bool?" Value="@isChecked" Change="@CheckedChange" Style="@(ParentItem != null && !HasChildren ? "margin-left:25px;margin-right:5px;" : "margin-right:5px;")" />
        }
        @if (Template != null)
        {
            @Template(this)
        } else
        {
            <span class="rz-treenode-label">@Text</span>
        }
    </div>
    @if (ChildContent != null && expanded)
    {
    <ul class="rz-treenode-children">
        @ChildContent
    </ul>
    }
</li>

@code {
    [Parameter]
    public RenderFragment ChildContent { get; set; }

    [Parameter]
    public RenderFragment<RadzenTreeItem> Template { get; set; }

    [Parameter]
    public string Text { get; set; }

    private bool expanded;

    [Parameter]
    public bool Expanded { get; set; }

    [Parameter]
    public object Value { get; set; }

    [Parameter]
    public bool HasChildren { get; set; }

    private bool selected;

    [Parameter]
    public bool Selected { get; set; }

    [CascadingParameter]
    public RadzenTree Tree { get; set; }

    RadzenTreeItem _parentItem;

    [Parameter]
    public RadzenTreeItem ParentItem
    {
        get
        {
            return _parentItem;
        }
        set
        {
            if (_parentItem != value)
            {
                _parentItem = value;

                if (_parentItem != null)
                {
                    _parentItem.AddItem(this);
                }
            }
        }
    }

    internal List<RadzenTreeItem> items = new List<RadzenTreeItem>();

    internal void AddItem(RadzenTreeItem item)
    {
        if (items.IndexOf(item) == -1)
        {
            items.Add(item);

            if (Tree != null && Tree.AllowCheckChildren)
            {
                item.SetIsChecked(isChecked);
                
                if (Tree.CheckedItems != null && Tree.CheckedItems.Contains(item.Value))
                {
                    item.SetIsChecked(true);
                }
            }
        }
    }

    internal void RemoveItem(RadzenTreeItem item)
    {
        if (items.IndexOf(item) != -1)
        {
            items.Remove(item);

            if (Tree != null && Tree.AllowCheckChildren)
            {
                item.SetIsChecked(isChecked);
            }
        }
    }

    public void Dispose()
    {
        if (ParentItem != null)
        {
            ParentItem.RemoveItem(this);
        }
        else if(Tree != null)
        {
            Tree.RemoveItem(this);
        }
    }

    async Task Toggle()
    {
        expanded = !expanded;

        if (expanded)
        {
            await Tree?.ExpandItem(this);
        }
    }

    void Select()
    {
        selected = true;
        Tree?.SelectItem(this);
    }

    internal void Unselect()
    {
        selected = false;
        StateHasChanged();
    }

    internal void RenderChildContent(RenderFragment content)
    {
        ChildContent = content;
    }

    override protected void OnInitialized()
    {
        expanded = Expanded;

        if (expanded)
        {
            Tree?.ExpandItem(this);
        }

        selected = Selected;

        if (selected)
        {
            Tree?.SelectItem(this);
        }

        if (Tree != null && ParentItem == null)
        {
            Tree.AddItem(this);
        }
    }

    public override async Task SetParametersAsync(ParameterView parameters)
    {
        var shouldExpand = false;

        if (parameters.DidParameterChange(nameof(Expanded), Expanded))
        {
            // The Expanded property has changed - update the expanded state
            expanded = parameters.GetValueOrDefault<bool>(nameof(Expanded));
            shouldExpand = true;
        }

        if (parameters.DidParameterChange(nameof(Value), Value))
        {
            // The Value property has changed - the children may have also changed
            shouldExpand = expanded;
        }

        if (shouldExpand)
        {
            // Either the expanded state or Value changed - expand the node to render its children
            Tree?.ExpandItem(this);
        }

        if (parameters.DidParameterChange(nameof(Selected), Selected))
        {
            selected = parameters.GetValueOrDefault<bool>(nameof(Selected));

            if (selected)
            {
                Tree?.SelectItem(this);
            }
        }

        await base.SetParametersAsync(parameters);
    }

    internal bool? isChecked = false;

    internal void CheckedChange(bool? value)
    {
        SetIsChecked(value);

        if (Tree != null)
        {
            if (Tree.AllowCheckChildren)
            {
                CheckChildren(value);
            }

            if (Tree.AllowCheckParents)
            {
                UpdateParents();
            }
        }
    }

    internal void SetIsChecked(bool? value)
    {
        if (isChecked != value)
        {
            isChecked = value;

            var tree = GetTree();
            if (tree != null)
            {
                var checkedItems = tree.CheckedItems != null ? new List<object>(tree.CheckedItems) : new List<object>();

                if (value == false)
                {
                    if (Value != null && checkedItems.Contains(Value))
                    {
                        checkedItems.Remove(Value);
                    }
                }
                else
                {
                    if (Value != null && !checkedItems.Contains(Value))
                    {
                        checkedItems.Add(Value);
                    }
                }

                tree.SetCheckedItems(checkedItems).Wait();
            }
        }
    }

    internal bool AreAllChildrenChecked()
    {
        return items.Concat(items.SelectManyRecursive(i => i.items)).All(i => i.isChecked == true);
    }

    internal bool AreAllChildrenUnchecked()
    {
        return items.Concat(items.SelectManyRecursive(i => i.items)).SelectManyRecursive(i => i.items).All(i => i.isChecked == false);
    }

    internal bool IsAtLeastOneChildUnchecked()
    {
        return items.Concat(items.SelectManyRecursive(i => i.items)).SelectManyRecursive(i => i.items).Any(i => i.isChecked != true);
    }

    internal void CheckChildren(bool? value)
    { 
        foreach(var item in items)
        {
            item.SetIsChecked(value);

            item.items.ForEach(i => 
            {
                i.SetIsChecked(value);
                i.CheckChildren(value);
            });
        }
    }

    internal void UpdateParents()
    { 
        var p = ParentItem;
        while (p != null)
        {
            if (isChecked != true || p.IsAtLeastOneChildUnchecked())
            {
                p.SetIsChecked(null);
            }
            else
            {
                p.SetIsChecked(p.AreAllChildrenChecked());
            }

            p = p.ParentItem;
        }
    }

    internal RadzenTree GetTree()
    {
        RadzenTree tree = null;
        RadzenTreeItem p = ParentItem;
        while (p != null)
        {
            tree = p.Tree;
            p = p.ParentItem;
        }

        return tree;
    }
}