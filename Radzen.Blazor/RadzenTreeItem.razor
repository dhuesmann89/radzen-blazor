@using Radzen
@implements IDisposable
<li class="rz-treenode">
    <div class="@($"rz-treenode-content {(selected ? "rz-treenode-content-selected" : "")}")" @onclick="@Select">
        @if (ChildContent != null || HasChildren)
        {
            <span class="@($"rz-tree-toggler rzi {(expanded ? "rzi-caret-down" : "rzi-caret-right")}")" @onclick="@Toggle" @onclick:stopPropagation></span>
        }
        @if(Tree != null && Tree.AllowCheckBoxes)
        {
            <RadzenCheckBox TValue="bool?" Value="@isChecked" Change="@CheckedChange" Style="@(ParentItem != null && !HasChildren ? "margin-left:25px;margin-right:5px;" : "margin-right:5px;")" />
        }
        @if (Template != null)
        {
            @Template(this)
        } else
        {
            <span class="rz-treenode-label">@Text</span>
        }
    </div>
    @if (ChildContent != null && expanded)
    {
    <ul class="rz-treenode-children">
        @ChildContent
    </ul>
    }
</li>

@code {
    [Parameter]
    public RenderFragment ChildContent { get; set; }

    [Parameter]
    public RenderFragment<RadzenTreeItem> Template { get; set; }

    [Parameter]
    public string Text { get; set; }

    private bool expanded;

    [Parameter]
    public bool Expanded { get; set; }

    [Parameter]
    public object Value { get; set; }

    [Parameter]
    public bool HasChildren { get; set; }

    private bool selected;

    [Parameter]
    public bool Selected { get; set; }

    [CascadingParameter]
    public RadzenTree Tree { get; set; }

    RadzenTreeItem _parentItem;

    [Parameter]
    public RadzenTreeItem ParentItem
    {
        get
        {
            return _parentItem;
        }
        set
        {
            if (_parentItem != value)
            {
                _parentItem = value;

                if (_parentItem != null)
                {
                    _parentItem.AddItem(this);
                }
            }
        }
    }

    internal List<RadzenTreeItem> items = new List<RadzenTreeItem>();

    internal void AddItem(RadzenTreeItem item)
    {
        if (items.IndexOf(item) == -1)
        {
            items.Add(item);

            if (Tree != null && Tree.AllowCheckChildren)
            {
                item.isChecked = isChecked;
                
                if (Tree.CheckedItems != null && Tree.CheckedItems.Contains(item.Value))
                {
                    item.isChecked = true;
                }

                Tree.UpdateCheckedItems().Wait();
            }
        }
    }

    internal void RemoveItem(RadzenTreeItem item)
    {
        if (items.IndexOf(item) != -1)
        {
            items.Remove(item);

            if (Tree != null && Tree.AllowCheckChildren)
            {
                item.isChecked = isChecked;
                Tree.UpdateCheckedItems().Wait();
            }
        }
    }

    public void Dispose()
    {
        if (ParentItem != null)
        {
            ParentItem.RemoveItem(this);
        }
        else if(Tree != null)
        {
            Tree.RemoveItem(this);
        }
    }

    async Task Toggle()
    {
        expanded = !expanded;

        if (expanded)
        {
            await Tree?.ExpandItem(this);
        }
    }

    void Select()
    {
        selected = true;
        Tree?.SelectItem(this);
    }

    internal void Unselect()
    {
        selected = false;
        StateHasChanged();
    }

    internal void RenderChildContent(RenderFragment content)
    {
        ChildContent = content;
    }

    override protected void OnInitialized()
    {
        expanded = Expanded;

        if (expanded)
        {
            Tree?.ExpandItem(this);
        }

        selected = Selected;

        if (selected)
        {
            Tree?.SelectItem(this);
        }

        if (Tree != null && ParentItem == null)
        {
            Tree.AddItem(this);
        }
    }

    public override async Task SetParametersAsync(ParameterView parameters)
    {
        var shouldExpand = false;

        if (parameters.DidParameterChange(nameof(Expanded), Expanded))
        {
            // The Expanded property has changed - update the expanded state
            expanded = parameters.GetValueOrDefault<bool>(nameof(Expanded));
            shouldExpand = true;
        }

        if (parameters.DidParameterChange(nameof(Value), Value))
        {
            // The Value property has changed - the children may have also changed
            shouldExpand = expanded;
        }

        if (shouldExpand)
        {
            // Either the expanded state or Value changed - expand the node to render its children
            Tree?.ExpandItem(this);
        }

        if (parameters.DidParameterChange(nameof(Selected), Selected))
        {
            selected = parameters.GetValueOrDefault<bool>(nameof(Selected));

            if (selected)
            {
                Tree?.SelectItem(this);
            }
        }

        await base.SetParametersAsync(parameters);
    }

    internal bool? isChecked = false;

    internal async Task CheckedChange(bool? value)
    {
        isChecked = value;

        if (Tree != null)
        {
            if (Tree.AllowCheckChildren)
            {
                CheckChildren(value);
            }

            if (Tree.AllowCheckParents)
            {
                UpdateParents();
            }

            await Tree.UpdateCheckedItems();
        }
    }

    internal bool AreAllChildrenChecked()
    {
        return items.Concat(items.SelectManyRecursive(i => i.items)).All(i => i.isChecked == true);
    }

    internal bool AreAllChildrenUnchecked()
    {
        return items.Concat(items.SelectManyRecursive(i => i.items)).SelectManyRecursive(i => i.items).All(i => i.isChecked == false);
    }

    internal bool IsAtLeastOneChildUnchecked()
    {
        return items.Concat(items.SelectManyRecursive(i => i.items)).SelectManyRecursive(i => i.items).Any(i => i.isChecked != true);
    }

    internal void CheckChildren(bool? value)
    { 
        foreach(var item in items)
        {
            item.isChecked = value;

            item.items.ForEach(i => 
            {
                i.isChecked = value;
                i.CheckChildren(value);
            });
        }
    }

    internal void UpdateParents()
    { 
        var p = ParentItem;
        while (p != null)
        {
            if (isChecked != true || p.IsAtLeastOneChildUnchecked())
            {
                p.isChecked = null;
            }
            else
            {
                p.isChecked = p.AreAllChildrenChecked();
            }

            p = p.ParentItem;
        }
    }
}